#!/usr/bin/env python3
def access_nested_map(nested_map, path):
    """Access a nested map with a sequence of keys."""
    for key in path:
        nested_map = nested_map[key]
    return nested_map
import unittest
from utils import access_nested_map
class TestAccessNestedMap(unittest.TestCase):
    def test_access_nested_map(self):
        nested_map = {"a": {"b": {"c": 42}}}
        path = ("a", "b", "c")
        result = access_nested_map(nested_map, path)
        self.assertEqual(result, 42)
import unittest
from utils import access_nested_map
class TestAccessNestedMap(unittest.TestCase):
    def test_access_nested_map(self):
        # Test simple access
        self.assertEqual(access_nested_map({"a": 1}, ("a",)), 1)

        # Test nested access
        self.assertEqual(access_nested_map({"a": {"b": 2}}, ("a",)), {"b": 2})
        self.assertEqual(access_nested_map({"a": {"b": 2}}, ("a", "b")), 2)

        # Test deeper nesting
        self.assertEqual(access_nested_map({"x": {"y": {"z": 99}}}, ("x", "y", "z")), 99)

if __name__ == '__main__':
    unittest.main()
import unittest
from parameterized import parameterized
from utils import access_nested_map

class TestAccessNestedMap(unittest.TestCase):
    @parameterized.expand([
        ({"a": 1}, ("a",), 1),
        ({"a": {"b": 2}}, ("a",), {"b": 2}),
        ({"a": {"b": 2}}, ("a", "b"), 2),
    ])
    def test_access_nested_map(self, nested_map, path, expected):
        self.assertEqual(access_nested_map(nested_map, path), expected)

if __name__ == '__main__':
    unittest.main()
import unittest
from parameterized import parameterized
from utils import access_nested_map

class TestAccessNestedMap(unittest.TestCase):
    @parameterized.expand([
        ({}, ("a",), "a"),
        ({"a": 1}, ("a", "b"), "b"),
    ])
    def test_access_nested_map_exception(self, nested_map, path, expected_key):
        with self.assertRaises(KeyError) as context:
            access_nested_map(nested_map, path)
        self.assertEqual(str(context.exception), f"'{expected_key}'")

if __name__ == '__main__':
    unittest.main()
utils.get_json is a function that takes a URL and returns a JSON response (parsed into a Python dictionary).

It uses requests.get(url).json() under the hood.

We’ll use unittest.mock to patch requests.get so the test doesn’t make real HTTP calls.
import unittest
from unittest.mock import patch, Mock
from parameterized import parameterized
from utils import get_json

class TestGetJson(unittest.TestCase):
    @parameterized.expand([
        ("http://example.com", {"payload": True}),
        ("http://holberton.io", {"payload": False}),
    ])
    @patch("utils.requests.get")
    def test_get_json(self, test_url, test_payload, mock_get):
        # Set up mock to return a response with .json() method
        mock_response = Mock()
        mock_response.json.return_value = test_payload
        mock_get.return_value = mock_response

        result = get_json(test_url)
        self.assertEqual(result, test_payload)
        mock_get.assert_called_once_with(test_url)

if __name__ == "__main__":
    unittest.main()
